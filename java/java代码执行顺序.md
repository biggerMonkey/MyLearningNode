 **1.加载静态成员/代码块：** 先递归地加载父类的静态成员/代码块(Object的最先)；再依次加载到本类的静态成员。

 **同一个类里的静态成员/代码块，按写代码的顺序加载。** 如果其间调用静态方法，则调用时会先运行静态方法，再继续加载。同一个类里调用静态方法时，可以不理会写代码的顺序。 调用父类的静态成员，可以像调用自己的一样；但调用其子类的静态成员，必须使用“子类名.成员名”来调用。 

**2.加载非静态成员/代码块：（**实例块在创建对象时才会被加载。而静态成员在不创建对象时可以加载） 先递归地加载父类的非静态成员/代码块(Object的最先)；再依次加载到本类的非静态成员。

 **同一个类里的非静态成员/代码块，按写代码的顺序加载。**同一个类里调用方法时，可以不理会写代码的顺序。 但调用属性时，必须注意加载顺序。一般编译不通过，如果能在加载前调用，值为默认初始值(如：null 或者 0)。 调用父类的非静态成员(private 除外)，也可以像调用自己的一样。 

**3.调用构造方法：****先递归地调用父类的构造方法(Object的最先)也就是上溯下行；**默认调用父类空参的，也可在第一行写明调用父类某个带参的。 再依次到本类的构造方法；构造方法内，也可在第一行写明调用某个本类其它的构造方法。 注意：如果加载时遇到 override 的成员，可看作是所需创建的类型赋值给当前类型。 

其调用按多态用法：只有非静态方法有多态；而静态方法、静态属性、非静态属性都没有多态。 假设子类override父类的所有成员，包括静态成员、非静态属性和非静态方法。 

由于构造子类时会先构造父类；而构造父类时，其所用的静态成员和非静态属性是父类的，但非静态方法却是子类的；

 由于构造父类时，子类并未加载；如果此时所调用的非静态方法里有成员，则这个成员是子类的，且非静态属性是默认初始值的。